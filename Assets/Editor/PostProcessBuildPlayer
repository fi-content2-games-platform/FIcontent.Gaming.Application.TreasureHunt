#!/usr/bin/python

# ============================================================================
# Copyright (c) 2010-2013 Qualcomm Connected Experiences, Inc.
# All Rights Reserved.
# Proprietary - Qualcomm Connected Experiences, Inc.
# ============================================================================


# Purpose of this post build script is to post process the project.pbxproj file
# generated by Unity to add any additional Libraries, Frameworks or build paths
# needed to build a QCAR app then add calls to the QCAR library into the Unity
# generated C code

# version date 6/6/14

import sys
import os


#Update with constants since Unity 4.1
UNITY_35 = 35
UNITY_40 = 40
UNITY_41 = 41
UNITY_42 = 42
UNITY_45 = 45
UNITY_451 = 451

#default to Unity 3.5.x, but based on discovery of certain files
# 1) iPhone_View.mm > UNITY_40
# 2) DisplayManager.mm > UNITY_41 overrides 1)
# 3) UnityAppController.mm > UNITY_42 overrides 2)
UnityVersion = UNITY_35


# Constants
FRAMEWORK_NAME = 0
FRAMEWORK_ID = 1
FRAMEWORK_FILEREFID = 2

RESFILE_NAME = 0
RESFILE_ID = 1
RESFILE_FILEREFID = 2
RESFILE_LASTKNOWNTYPE = 3

# These ids have been generated by creating a project using Xcode then
# extracting the values from the generated project.pbxproj.  The format of this
# file is not documented by Apple so the correct algorithm for generating these
# ids is unknown

AVFOUNDATION_ID = 'CCE8C2AB135C7CDD000D8035'
AVFOUNDATION_FILEREFID = 'CCE8C2AA135C7CDD000D8035'

COREVIDEO_ID = 'CC375CE01316C2C5004F0FDD'
COREVIDEO_FILEREFID = 'CC375CDF1316C2C5004F0FDD'

COREMEDIA_ID = 'CC375CE51316C2D3004F0FDD'
COREMEDIA_FILEREFID = 'CC375CE41316C2D3004F0FDD'

SECURITY_ID = 'CCE8C2BA135C7EA3000D8035'
SECURITY_FILEREFID = 'CCE8C2B9135C7EA3000D8035'

QCARDIR_ID = 'CC9FCA1D1445D76E004F4DC3'
QCARDIR_FILEREFID = 'CC9FCA171445D76E004F4DC3'



# List of all the frameworks to be added to the project
frameworks = [["AVFoundation.framework", AVFOUNDATION_ID, AVFOUNDATION_FILEREFID], \
              ["CoreMedia.framework", COREMEDIA_ID, COREMEDIA_FILEREFID], \
              ["CoreVideo.framework", COREVIDEO_ID, COREVIDEO_FILEREFID], \
              ["Security.framework", SECURITY_ID, SECURITY_FILEREFID]]

# List of data files to be added to the app bundle
resfiles = [["QCAR", QCARDIR_ID, QCARDIR_FILEREFID, 'folder']]



# Adds a line into the PBXBuildFile section
def add_build_file(pbxproj, id, name, fileref):
    subsection = 'Resources'
    if name[-9:] == 'framework':
        subsection = 'Frameworks'
    print "Adding build file " + name + '\n'
    pbxproj.write('\t\t' + id + ' /* ' + name  + ' in ' + subsection + ' */ = {isa = PBXBuildFile; fileRef = ' + fileref +  ' /* ' + name + ' */; };\n')

#Adds a line to the PBXFileReference to add a resource file
def add_res_file_reference(pbxproj, id, name, last_known_file_type):
    print "Adding data file reference " + name + "\n"
    pbxproj.write('\t\t' + id + ' /* ' + name + ' */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = ' + last_known_file_type + '; name = ' + name + '; path = Data/Raw/' + name + '; sourceTree = SOURCE_ROOT; };\n')

# Adds a line into the PBXFileReference section to add a framework
def add_framework_file_reference(pbxproj, id, name):
    print "Adding framework file reference " + name + '\n'
    pbxproj.write('\t\t' + id + ' /* ' + name + ' */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = ' + name + '; path = System/Library/Frameworks/' + name + '; sourceTree = SDKROOT; };\n')

# Adds a line into the PBXFrameworksBuildPhase section
def add_frameworks_build_phase(pbxproj, id, name):
    print "Adding build phase " + name + '\n'
    pbxproj.write('\t\t\t\t' + id + ' /* ' + name + ' in Frameworks */,\n')

# Adds a line into the PBXResourcesBuildPhase section
def add_resources_build_phase(pbxproj, id, name):
    print "Adding build phase " + name + '\n'
    pbxproj.write('\t\t\t\t' + id + ' /* ' + name + ' in Resources */,\n')

# Adds a line into the PBXGroup section
def add_group(pbxproj, id, name):
    print "Add group " + name + '\n'
    pbxproj.write('\t\t\t\t' + id + ' /* ' + name + ' */,\n')

# Returns a list of all the files already in a pbxproj
#    lines - a list of all the lines read in from a pbxproj
def read_existing_files(lines):
    begin_pbxbuildfile_section = False
    existing_files = []
    i = 0
    line = lines[i]
    while line[3:6] != 'End':
        if not begin_pbxbuildfile_section:
            begin_pbxbuildfile_section = (line[3:21] == 'Begin PBXBuildFile')
        else:
            existing_files.append(line.split()[2])
        i = i + 1
        line = lines[i]

    return existing_files


# Processes the given xcode project to add or change the supplied parameters
#   xcodeproj_filename - filename of the Xcode project to change
#   frameworks - list of Apple standard frameworks to add to the project
#   resfiles - list resource files added to the project
def process_pbxproj(xcodeproj_filename, frameworks, resfiles):

    # Open up the file generated by Unity and read into memory as
    # a list of lines for processing
    pbxproj_filename = xcodeproj_filename + '/project.pbxproj'
    pbxproj = open(pbxproj_filename, 'r')
    lines = pbxproj.readlines()
    pbxproj.close()

    # Work out which of the resfiles exist and remove them if they don't, this
    # is because if using frame markers there may not be a qcar-resources.dat
    resfiles = [x for x in resfiles if os.path.exists(xcodeproj_filename + '/../Data/Raw/' + x[RESFILE_NAME])]

    # Next open up an empty project.pbxproj for writing and iterate over the old
    # file copying the original file and inserting anything extra we need
    pbxproj = open(pbxproj_filename, 'w')

    # As we iterate through the list we'll record which section of the
    # project.pbxproj we are currently in
    section = ''

    # We use these booleans to decide whether we have already added the list of
    # build files to the link line.  This is needed because there could be multiple
    # build targets and they are not named in the project.pbxproj
    frameworks_build_added = False
    res_build_added = False

    # Build a list of the files already added to the project.  Then use it to
    # avoid adding anything to the project twice
    existing_files = read_existing_files(lines)
    filtered_frameworks = []
    for framework in frameworks:
        if framework[0] not in existing_files:
            filtered_frameworks.append(framework)
    frameworks = filtered_frameworks
    for resfile in resfiles:
        if resfile[0] in existing_files:
            resfiles.remove(resfile)
    
   
    # Now iterate through the project adding any new lines where needed
    i = 0
    for i in range(0, len(lines)):
        line = lines[i]
        pbxproj.write(line)

        # Each section starts with a comment such as
        # /* Begin PBXBuildFile section */'
        if line[3:8] == 'Begin':
            section = line.split(' ')[2]
            if section == 'PBXBuildFile':
                for framework in frameworks:
                    add_build_file(pbxproj, framework[FRAMEWORK_ID], framework[FRAMEWORK_NAME], framework[FRAMEWORK_FILEREFID])
                for resfile in resfiles:
                    add_build_file(pbxproj, resfile[RESFILE_ID], resfile[RESFILE_NAME], resfile[RESFILE_FILEREFID])

            if section == 'PBXFileReference':
                for framework in frameworks:
                    add_framework_file_reference(pbxproj, framework[FRAMEWORK_FILEREFID], framework[FRAMEWORK_NAME])
                for resfile in resfiles:
                    add_res_file_reference(pbxproj, resfile[RESFILE_FILEREFID], resfile[RESFILE_NAME], resfile[RESFILE_LASTKNOWNTYPE])
    
        if line[3:6] == 'End':
            section = ''
   
        if section == 'PBXFrameworksBuildPhase':
            if line.strip()[0:5] == 'files':
                if not frameworks_build_added:
                    for framework in frameworks:
                        add_frameworks_build_phase(pbxproj, framework[FRAMEWORK_ID], framework[FRAMEWORK_NAME])
                    frameworks_build_added = True

        # The PBXResourcesBuildPhase section is what appears in XCode as 'Link
        # Binary With Libraries'.  As with the frameworks we make the assumption the
        # first target is always 'Unity-iPhone' as the name of the target itself is
        # not listed in project.pbxproj
        if section == 'PBXResourcesBuildPhase':
            if line.strip()[0:5] == 'files':
                if not res_build_added:
                    for resfile in resfiles:
                        add_resources_build_phase(pbxproj,resfile[RESFILE_ID], resfile[RESFILE_NAME])
                    res_build_added = True

        # The PBXGroup is the section that appears in XCode as 'Copy Bundle Resources'. 
        if section == 'PBXGroup':
            if (line.strip()[0:8] == 'children') and (lines[i-2].strip().split(' ')[2] == 'CustomTemplate'):
                for resfile in resfiles:
                    add_group(pbxproj, resfile[RESFILE_FILEREFID], resfile[RESFILE_NAME])
                for framework in frameworks:
                    add_group(pbxproj, framework[FRAMEWORK_FILEREFID], framework[FRAMEWORK_NAME])

        # The PBXShellScriptBuildPhase appears in Xcode 4 as "Run Script", we need to delete the QCAR
        # directory from the app to avoid a duplicate copy
        if section == 'PBXShellScriptBuildPhase':
            if (line.strip()[0:11] == 'shellScript'):
                pbxproj.seek(-3, os.SEEK_CUR)
                pbxproj.write('\\nrm -rf \\"$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Data/Raw/QCAR\\"\";\n')

        # change for Unity 4.2 because header search path needs to be in HEADER_SEARCH_PATHS group
        if section == 'XCBuildConfiguration':
            if (UnityVersion == UNITY_42 or UnityVersion == UNITY_45 or UnityVersion == UNITY_451):
                if line.strip()[0:23] == 'HEADER_SEARCH_PATHS = (':
                    pbxproj.write('\t\t\t\t\t\"$(SRCROOT)/Libraries\",\n')
            else:
                if line.strip()[0:13] == 'buildSettings':
                    pbxproj.write('\t\t\t\tHEADER_SEARCH_PATHS = \"$(SRCROOT)/Libraries\";\n')

    pbxproj.close()


# Processes a Unity generated AppController.mm to add calls to QCARUnityPlayer
#   appcontroller_filename - full path to AppController.mm to be modified
def process_appcontroller(appcontroller_filename):
    global UnityVersion
    found_CreateSurface = False

    appcontroller = open(appcontroller_filename, 'r')
    lines = appcontroller.readlines()
    appcontroller.close()
   
    # Check to see if file looks like it has alread been processed and
    # only process if it has not
    if lines[0] != '#include \"QCARUnityPlayer.h\"\n':
 
        appcontroller = open(appcontroller_filename, 'w')

        skip = False

        appcontroller.write('#include "QCARUnityPlayer.h"\n');

        # write this out at the top of the file now
        if UnityVersion == UNITY_40:
            appcontroller.write('extern int _curOrientation;\n')
        elif UnityVersion == UNITY_41:
            appcontroller.write('extern int _curOrientation;\n')

        for i in range(0, len(lines)):
            line = lines[i]
            # Look for CreateSurface and add calls to the end of the function
            if line[0:19] == 'bool CreateSurface(':
                found_CreateSurface = True
            if found_CreateSurface and (line.strip() == 'return true;'):                
                found_CreateSurface = False
                if UnityVersion == UNITY_40:
                    appcontroller.write('\tQCARUnityPlayer::getInstance().QCARNotifyCreated((int)surface->systemW, (int)surface->systemH);\n')
                elif UnityVersion == UNITY_35:
                    appcontroller.write('\tQCARUnityPlayer::getInstance().QCARNotifyCreated((int)surface->w, (int)surface->h);\n')

            # Add QCAR lifecycle calls next to the Unity equivalents 
            if line.strip()[0:18] == 'UnityPause(false);':
                appcontroller.write('\t\tQCARUnityPlayer::getInstance().QCARPause(false);\n')

            if line.strip()[0:17] == 'UnityPause(true);':
                appcontroller.write('\tUnityPause(true);\n')

                if UnityVersion != UNITY_41:
                    appcontroller.write('\tPresentSurface(&_surface);\n')

                appcontroller.write('\tQCARUnityPlayer::getInstance().QCARPause(true);\n')
                skip = True

            if UnityVersion in (UNITY_35, UNITY_40) and line.strip()[0:30] == '[self startUnity:application];' or \
               UnityVersion == UNITY_41 and line.strip()[0:82] == '[self performSelector:@selector(startUnity:) withObject:application afterDelay:0];' :
                    appcontroller.write('\tNSString* orientation = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"UIInterfaceOrientation"];\n\n');
                    appcontroller.write('\tQCARUnityPlayer::getInstance().QCARInit([orientation UTF8String]);\n');                
                    appcontroller.write('\tQCARUnityPlayer::getInstance().QCARSetOrientation(_curOrientation);\n');

            if line.strip()[0:15] == 'UnityCleanup();':
                appcontroller.write('\tQCARUnityPlayer::getInstance().destroy();\n');

            # Unity 357 additional compatibility
            if UnityVersion == UNITY_35:
                if line.strip()[0:43] == 'UnitySetScreenOrientation(requestedOrient);':
                    appcontroller.write('\t\tQCARUnityPlayer::getInstance().QCARSetOrientation(requestedOrient);\n');

    
            # these two lines below appear to be redundant
            if line.strip()[0:43] == 'UnitySetScreenOrientation(_curOrientation);':
               appcontroller.write('\tQCARUnityPlayer::getInstance().QCARSetOrientation(_curOrientation);\n');

            # Leave display link enabled as it improves performance by around 3-4%
            # 11 Oct 2012
            # Leave all other settings unchanged as tested on Unity 3.5.6 and for Unity 4 they are going DisplayLink only
            
            # if line == '#define USE_DISPLAY_LINK_IF_AVAILABLE 1\n':
            #    appcontroller.write('#define USE_DISPLAY_LINK_IF_AVAILABLE 0\n');
            #    skip = True

            # if line == '//#define FALLBACK_LOOP_TYPE THREAD_BASED_LOOP\n':
            #    appcontroller.write('#define FALLBACK_LOOP_TYPE THREAD_BASED_LOOP\n');
            #    skip = True

            # if line == '#define FALLBACK_LOOP_TYPE EVENT_PUMP_BASED_LOOP\n':
            #    appcontroller.write('//#define FALLBACK_LOOP_TYPE EVENT_PUMP_BASED_LOOP\n');
            #    skip = True


            # write out original line of code if it has not been replaced
            if not skip:
                appcontroller.write(line)
            skip = False

        appcontroller.close()



# Processes a Unity generated iPhoneView.mm to tweak _curOrientation to make it non static so it can be referenced by AppController.mm
def process_iPhoneView(iPhoneView_filename):
    global UnityVersion
    
    try:
        #using the presence of this file to determine if it is Unity Version 4
        iPhoneView = open(iPhoneView_filename, 'r')
        lines = iPhoneView.readlines()
        iPhoneView.close()
        UnityVersion = UNITY_40

    except IOError:
        return
    
    # Check to see if file looks like it has already been processed and
    # only process if it has not
    if lines[0] != '#include \"QCARUnityPlayer.h\"\n':
        
        iPhoneView = open(iPhoneView_filename, 'w')
                
        skip = False
                
        iPhoneView.write('#include "QCARUnityPlayer.h"\n');
        for i in range(0, len(lines)):
            line = lines[i]
           
            #change for Unity 4.3
            if line.strip()[0:40] == 'static ScreenOrientation\t_curOrientation':
                iPhoneView.write('ScreenOrientation _curOrientation = orientationUnknown;\n');
                skip = True

            #if line.strip()[0:62] == 'static ScreenOrientation _curOrientation = orientationUnknown;':
            #change for Unity 4.2.b1 29/5/13 - tested with Unity 4.1.3f1 as well
            if line.strip()[0:40] == 'static ScreenOrientation _curOrientation':
                iPhoneView.write('ScreenOrientation _curOrientation = orientationUnknown;\n');
                skip = True
            
            #deal with fixed orientation issue
            if line.strip()[0:43] == 'UnitySetScreenOrientation(_curOrientation);':                
                iPhoneView.write('\tQCARUnityPlayer::getInstance().QCARSetOrientation(_curOrientation);\n\n');
                skip = False

            if line.strip()[0:43] == 'UnitySetScreenOrientation(requestedOrient);':                
                iPhoneView.write('\tQCARUnityPlayer::getInstance().QCARSetOrientation(requestedOrient);\n\n');
                skip = False

            #change for Unity 4.2.b1 29/5/13
            if line.strip()[0:57] == '[GetAppController() onForcedOrientation:requestedOrient];':
                iPhoneView.write('\t\tQCARUnityPlayer::getInstance().QCARSetOrientation(requestedOrient);\n\n');
                skip = False

            
            # write out original line of code if it has not been replaced
            if not skip:
                iPhoneView.write(line)
            skip = False
        
        iPhoneView.close()


# For Unity 4.1 Processes a Unity generated DisplayManager.mm
def process_DisplayManager(DisplayManager_filename):
    global UnityVersion
    
    try:
        #using the presence of this file to determine if it is Unity Version 4
        DisplayManager = open(DisplayManager_filename, 'r')
        lines = DisplayManager.readlines()
        DisplayManager.close()
        UnityVersion = UNITY_41
    
    except IOError:
        return
    
    # Check to see if file looks like it has already been processed and
    # only process if it has not
    if lines[0] != '#include \"QCARUnityPlayer.h\"\n':
        
        DisplayManager = open(DisplayManager_filename, 'w')
        
        skip = False
        
        DisplayManager.write('#include "QCARUnityPlayer.h"\n')
        for i in range(0, len(lines)):
            line = lines[i]
            
            # in Unity 4.1 Notify Created has moved here           
            if line.strip()[0:36] == 'CreateUnityRenderBuffers(&surface);':
                
                # write original line first
                DisplayManager.write(line)
                
                DisplayManager.write('\n\n\tQCARUnityPlayer::getInstance().QCARNotifyCreated((int)surface.systemW, (int)surface.systemH);\n')
                skip = True
        
            # write out original line of code if it has not been replaced
            if not skip:
                DisplayManager.write(line)
            skip = False

        DisplayManager.close()


# For Unity 4.2 Processes a Unity generated UnityAppController.mm
def process_UnityAppController(UnityAppController_filename):
    global UnityVersion
    
    try:
        #using the presence of this file to determine if it is Unity Version 4
        UnityAppController = open(UnityAppController_filename, 'r')
        lines = UnityAppController.readlines()
        UnityAppController.close()
        #UnityVersion = UNITY_42

    except IOError:
        return

    # Check to see if file looks like it has already been processed and
    # only process if it has not
    if lines[0] != '#include \"QCARUnityPlayer.h\"\n':
        
        UnityAppController = open(UnityAppController_filename, 'w')
        
        skip = False
        
        # write this out at the top of the file
        UnityAppController.write('#include "QCARUnityPlayer.h"\n')
        UnityAppController.write('extern int _curOrientation;\n')

        for i in range(0, len(lines)):
            line = lines[i]
            
            # in Unity 4.2 at bottom of didFinishLaunchingWithOptions
            if line.strip()[0:82] == '[self performSelector:@selector(startUnity:) withObject:application afterDelay:0];' :
                UnityAppController.write('\tNSString* orientation = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"UIInterfaceOrientation"];\n\n');
                UnityAppController.write('\tQCARUnityPlayer::getInstance().QCARInit([orientation UTF8String]);\n');
                
                if UnityVersion == UNITY_42:
                    UnityAppController.write('\tQCARUnityPlayer::getInstance().QCARSetOrientation(_curOrientation);\n');
                elif UnityVersion == UNITY_45 or UnityVersion == UNITY_451:
                    UnityAppController.write('\tQCARUnityPlayer::getInstance().QCARSetOrientation([_unityView contentOrientation]);\n');

            if line.strip()[0:17] == 'UnityPause(true);':
                UnityAppController.write('\t\tQCARUnityPlayer::getInstance().QCARPause(true);\n')

            if line.strip()[0:15] == 'UnityCleanup();':
                UnityAppController.write('\tQCARUnityPlayer::getInstance().destroy();\n');

            # write out original line of code if it has not been replaced
            # note that at present skip is always False, because the original line will always get written out.
            # It has been left in here in case where lines in the future may need to be replaced rather than just appended to.
            if not skip:
                UnityAppController.write(line)
            skip = False

        UnityAppController.close()




# For Unity 4.2 upwards Processes a Unity generated UnityView.mm to handle autorotation
def process_UnityView(UnityView_filename):
    global UnityVersion
    
    try:
        #try to read lines of file
        UnityView = open(UnityView_filename, 'r')
        lines = UnityView.readlines()
        UnityView.close()
    
    except IOError:
        return
    
    # Check to see if file looks like it has already been processed and
    # only process if it has not
    if lines[0] != '#include \"QCARUnityPlayer.h\"\n':
        
        UnityView = open(UnityView_filename, 'w')
        
        skip = False
        
        # write this out at the top of the file
        UnityView.write('#include "QCARUnityPlayer.h"\n')
        
        for i in range(0, len(lines)):
            line = lines[i]
            
            # in Unity 4.2 at bottom of - (void)willRotateTo:(ScreenOrientation)orientation
            if line.strip()[0:43] == 'UnitySetScreenOrientation(_curOrientation);' :
                UnityView.write('\tQCARUnityPlayer::getInstance().QCARSetOrientation(_curOrientation);\n');
            
            # fix for 4.5.1 - write this out in LayoutSubviews instead
            if UnityVersion == UNITY_451 and line.strip()[0:23] == '[super layoutSubviews];' :
                UnityView.write('\tQCARUnityPlayer::getInstance().QCARSetOrientation(_curOrientation);\n');
            
            # write out original line of code if it has not been replaced
            # note that at present skip is always False, because the original line will always get written out.
            # It has been left in here in case where lines in the future may need to be replaced rather than just appended to.
            if not skip:
                UnityView.write(line)
            skip = False
        
        UnityView.close()


# in here it will just parse to see if it is Unity_45, or Unity_451
def process_UnityViewCheckUnity45(UnityView_filename):
    global UnityVersion
    
    try:
        #try to read lines of file
        UnityView = open(UnityView_filename, 'r')
        lines = UnityView.readlines()
        UnityView.close()
        UnityVersion = UNITY_42
    
    except IOError:
        return
    

    # Check to see if file looks like it has already been processed and
    # only process if it has not
    if lines[0] != '#include \"QCARUnityPlayer.h\"\n':
        
        for i in range(0, len(lines)):
            line = lines[i]
            
            # test for Unity_45
            if line.strip()[0:25] == '@implementation UnityView' :
                UnityVersion = UNITY_45

            if line.strip()[0:21] == 'UnityReportResizeView' :
                UnityVersion = UNITY_451


# Script start
print "Starting PostProcessBuildPlayer with the following arguments..."

i = 0
for args in sys.argv:
    print str(i) +': ' + args
    i += 1

# Check this is an iOS build before running
if sys.argv[2] == "iPhone":

    # check for Unity 4.0.x first
    iPhoneView_full_path_name = sys.argv[1] + '/Classes/iPhone_View.mm'
    process_iPhoneView(iPhoneView_full_path_name)

    # Check for Unity 4.1 second, because iPhone_View changes above are still required for 4.1
    DisplayManager_full_path_name = sys.argv[1] + '/Classes/Unity/DisplayManager.mm'
    process_DisplayManager(DisplayManager_full_path_name)

    # Check for Unity 4.5 - parse the UnityView.mm file first looking for @implementation UnityView
    UnityView_full_path_name = sys.argv[1] + '/Classes/UI/UnityView.mm'
    process_UnityViewCheckUnity45(UnityView_full_path_name)

    # Check for Unity 4.2 third, because iPhone_View changes above are still required for 4.2
    UnityAppController_full_path_name = sys.argv[1] + '/Classes/UnityAppController.mm'
    process_UnityAppController(UnityAppController_full_path_name)
    
    # Fix for autorotation issue just on Unity 4.2
    if (UnityVersion == UNITY_42 or UnityVersion == UNITY_45 or UnityVersion == UNITY_451):
        UnityView_full_path_name = sys.argv[1] + '/Classes/UI/UnityView.mm'
        process_UnityView(UnityView_full_path_name)
    
    
    # if it is not Unity 4.2 then we need to process the appcontroller file
    else:
        appcontroller_full_path_name = sys.argv[1] + '/Classes/AppController.mm'
        process_appcontroller(appcontroller_full_path_name)

    # do this afterwards as there is now a dependency on Unity4.2
    xcodeproj_full_path_name = sys.argv[1] + '/Unity-iPhone.xcodeproj'
    process_pbxproj(xcodeproj_full_path_name, frameworks, resfiles)


